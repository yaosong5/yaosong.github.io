{"meta":{"title":"钢铁锅","subtitle":"应尽便须尽，无复独多虑","description":"纵浪大化中，不喜亦不悲","author":"GTG","url":"http://gangtieguo.cn"},"pages":[{"title":"","date":"2018-05-18T06:50:40.014Z","updated":"2018-05-17T01:53:01.988Z","comments":true,"path":"baidu_verify_WHXmBFaAkY.html","permalink":"http://gangtieguo.cn/baidu_verify_WHXmBFaAkY.html","excerpt":"","text":"WHXmBFaAkY"},{"title":"","date":"2018-05-18T06:50:40.022Z","updated":"2018-05-17T02:15:40.515Z","comments":true,"path":"google00655d7c846aab3a.html","permalink":"http://gangtieguo.cn/google00655d7c846aab3a.html","excerpt":"","text":"google-site-verification: google00655d7c846aab3a.html"},{"title":"404 Not Found：该页无法显示","date":"2018-05-18T06:50:42.172Z","updated":"2018-05-08T10:00:51.508Z","comments":false,"path":"/404.html","permalink":"http://gangtieguo.cn//404.html","excerpt":"","text":""},{"title":"about","date":"2018-05-08T07:52:07.000Z","updated":"2018-05-08T07:53:31.549Z","comments":true,"path":"about/index.html","permalink":"http://gangtieguo.cn/about/index.html","excerpt":"","text":"nothing"},{"title":"Categories","date":"2018-05-18T06:50:42.194Z","updated":"2018-04-30T00:06:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://gangtieguo.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-18T06:50:42.204Z","updated":"2018-04-30T00:06:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://gangtieguo.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker安装Hadoop集群","slug":"Docker安装Hadoop集群","date":"2018-06-03T06:36:21.404Z","updated":"2018-06-04T01:33:15.648Z","comments":true,"path":"2018/06/03/Docker安装Hadoop集群/","link":"","permalink":"http://gangtieguo.cn/2018/06/03/Docker安装Hadoop集群/","excerpt":"Docker配置Hadoop集群环境 在网上找到一个网友自制的镜像，拉取配置都是参考的，记录一下。 拉取镜像 sudo docker pull kiwenlau/hadoop-master:0.1.0sudo docker pull kiwenlau/hadoop-slave:0.1.0sudo docker pull kiwenlau/hadoop-base:0.1.0sudo docker pull kiwenlau/serf-dnsmasq:0.1.0 查看下载的镜像 sudo docker images 在github中拉取源代码(或者在oschina中拉取)git clone https://github.com/kiwenlau/hadoop-cluster-docker开源中国git clone http://git.oschina.net/kiwenlau/hadoop-cluster-docker 运行容器拉取镜像后，打开源代码文件夹，并且运行脚本 cd hadoop-cluster-docker 注意：运行脚本时,需要先启动docker服务 ./start-container.sh 一共开启了 3 个容器，1 个 master, 2 个 slave。开启容器后就进入了 master 容器 root 用户的根目录（/root） 查看root目录下文件 测试容器是否正常运行serf members","text":"Docker配置Hadoop集群环境 在网上找到一个网友自制的镜像，拉取配置都是参考的，记录一下。 拉取镜像 sudo docker pull kiwenlau/hadoop-master:0.1.0sudo docker pull kiwenlau/hadoop-slave:0.1.0sudo docker pull kiwenlau/hadoop-base:0.1.0sudo docker pull kiwenlau/serf-dnsmasq:0.1.0 查看下载的镜像 sudo docker images 在github中拉取源代码(或者在oschina中拉取)git clone https://github.com/kiwenlau/hadoop-cluster-docker开源中国git clone http://git.oschina.net/kiwenlau/hadoop-cluster-docker 运行容器拉取镜像后，打开源代码文件夹，并且运行脚本 cd hadoop-cluster-docker 注意：运行脚本时,需要先启动docker服务 ./start-container.sh 一共开启了 3 个容器，1 个 master, 2 个 slave。开启容器后就进入了 master 容器 root 用户的根目录（/root） 查看root目录下文件 测试容器是否正常运行serf members 参考：基于 Docker 快速搭建多节点 Hadoop 集群","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://gangtieguo.cn/categories/环境配置/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://gangtieguo.cn/tags/Docker/"},{"name":"Hadooop","slug":"Hadooop","permalink":"http://gangtieguo.cn/tags/Hadooop/"}]},{"title":"命令积累","slug":"大数据命令积累","date":"2018-05-31T06:10:40.710Z","updated":"2018-05-31T06:10:52.763Z","comments":true,"path":"2018/05/31/大数据命令积累/","link":"","permalink":"http://gangtieguo.cn/2018/05/31/大数据命令积累/","excerpt":"bin /h dfs oev -i edits -o edits.xml 查看元数据","text":"bin /h dfs oev -i edits -o edits.xml 查看元数据","categories":[],"tags":[]},{"title":"","slug":"json-tool使用","date":"2018-05-30T01:36:02.864Z","updated":"2018-05-30T01:52:55.449Z","comments":true,"path":"2018/05/30/json-tool使用/","link":"","permalink":"http://gangtieguo.cn/2018/05/30/json-tool使用/","excerpt":"","text":"json-tool使用：java -jar json-tool.jar &quot;json文件目录&quot; &quot;jsonPath路径&quot;示例：1java -jar /Users/yaosong/Documents/json-tool.jar &quot;/Users/yaosong/tmp/access_report_data_by_token.json&quot; &quot;$.report_data.behavior_check[?(@.check_point_cn == &apos;朋友圈在哪里&apos;)].evidence&quot;","categories":[],"tags":[]},{"title":"搭建DockerHadoop记录","slug":"搭建dockerHadoop记录","date":"2018-05-23T17:45:50.245Z","updated":"2018-05-30T01:33:13.207Z","comments":true,"path":"2018/05/24/搭建dockerHadoop记录/","link":"","permalink":"http://gangtieguo.cn/2018/05/24/搭建dockerHadoop记录/","excerpt":"sudo docker network create –driver=bridge hadoopcf55b0b0147d6dd670acc93a463a5524cd83f50a3ba7e23bc2d1c1164fb44c51","text":"sudo docker network create –driver=bridge hadoopcf55b0b0147d6dd670acc93a463a5524cd83f50a3ba7e23bc2d1c1164fb44c51","categories":[],"tags":[]},{"title":"源文件提交到仓库","slug":"博客源文件提交到仓库","date":"2018-05-21T17:43:07.025Z","updated":"2018-05-21T17:44:03.947Z","comments":true,"path":"2018/05/22/博客源文件提交到仓库/","link":"","permalink":"http://gangtieguo.cn/2018/05/22/博客源文件提交到仓库/","excerpt":"将博客源文件加入到仓库 git add .git commit -m “ “git push origin mastergit push origin master -f","text":"将博客源文件加入到仓库 git add .git commit -m “ “git push origin mastergit push origin master -f","categories":[{"name":"博客","slug":"博客","permalink":"http://gangtieguo.cn/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gangtieguo.cn/tags/Hexo/"},{"name":"git","slug":"git","permalink":"http://gangtieguo.cn/tags/git/"}]},{"title":"部署博客到云服务器","slug":"转移Github博客到云服务器","date":"2018-05-20T16:56:17.069Z","updated":"2018-05-21T16:55:37.674Z","comments":true,"path":"2018/05/21/转移Github博客到云服务器/","link":"","permalink":"http://gangtieguo.cn/2018/05/21/转移Github博客到云服务器/","excerpt":"简单记录转移到博客到云服务器","text":"简单记录转移到博客到云服务器 原理及准备 我们在自己的电脑上写好博客, 使用 git 发布到代码仓库进行备份, git 仓库接收到 push 请求后, 使用 webhook 配合 nodejs 自动进行服务器端页面的更新. 准备安装Git和NodeJS (CentOS 环境) 1yum install git 安装NodeJS 1curl --silent --location https://rpm.nodesource.com/setup_5.x | bash - 服务器构建webhook方式服务器端的” 钩子”我们借助一个 node 插件 github-webhook-handler 来快速完成配合 github webhook 的操作, 其他 git 平台也有相应的插件, 如配合 coding 的 coding-webhook-handler. 监听脚本 我们借助一个 node 插件 github webhook-handler来快速完成配合 github webhook 的操作, 其他 git 平台也有相应的插件, 如配合 coding 的 coding-webhook-handler. 使用 npm install -g github-webhook-handler 命令来安装到服务器端.conding则为npm install -g coding-webhook-handler 切换到服务器站点目录，如我的是 /root/blog,新建一个public目录，将你的github仓库中的master分支pull到该目录中，这个目录作为这个博客的根目录了 123456cd /root/blogmkdir public cd public git initgit remote add origin https://github.com/yaosong5/yaosong5.github.iogit pull origin master 然后我们创建一个webhooks.js文件，将以下的内容粘贴，这相当于Node.js 服务器的代码构建 123456789101112131415161718192021222324252627282930var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/', secret: 'yao' &#125;)function run_cmd(cmd, args, callback) &#123; var spawn = require('child_process').spawn; var child = spawn(cmd, args); var resp = \"\"; child.stdout.on('data', function(buffer) &#123; resp += buffer.toString(); &#125;); child.stdout.on('end', function() &#123; callback (resp) &#125;);&#125;http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(7777)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref); run_cmd('sh', ['./deploy.sh',event.payload.repository.name], function(text)&#123; console.log(text) &#125;);&#125;) 注意上段代码中第 3 行 { path: ‘/‘, secret: ‘改为你的secret’ } 中 secret 可以改为你喜欢的口令, 这口令将在下面的步骤中起到作用 ,配置github webhooks的时候填入的口令, 请留意. 第 19 行 listen(7777) 中 7777 为监听程序需要使用的端口. 执行脚本上面的 javascript 代码是用来捕捉 github 发来的信号并发起一个执行 ./deploy.sh 的脚本, 接下来我们还需要写 deploy.sh 的内容. 123456789101112#!/bin/bashWEB_PATH='/root/blog/public'echo \"Start deployment\"cd $WEB_PATHecho \"pulling source code...\"git reset --hard origin/mastergit clean -fgit pullgit checkout masterecho \"Finished.\" 将以上代码的第 3 行改为你服务器中的实际目录. 接下来只需要开启监听就可以了. tips: 在此之前你可以使用 node webhook.js 来测试一下监听程序是否能够正常运行.我在这里碰到了一个 node 环境变量的问题, 读取不到 github-webhook-handler 这个模块, 找了很多办法也没有解决, 后来我直接在项目根目录的上级目录安装了这个模块, 问题就解决了. cd /root/blognpm install github-webhook-handlernpm 会从当前目录依次向上寻找含有 node_modules 目录并访问该模块. 普通方式运行 webhook.js利用 Linux 提供的 nohup 命令，让 webhooks.js 运行在后台 1nohup node webhook.js &gt; deploy.log &amp; Forever方式运行webhook.js 我在实际使用的时候发现，我的 Node 服务器时不时会自动停掉，具体原因我暂时还没有弄清楚。不过似乎很多人都遇到了这样的困扰，要解决这个问题，forever 是个不错的选择。借助 forever 这个库，它可以保证 Node 持续运行下去，一旦服务器挂了，它都会重启服务器。 安装 forever：npm install -g forever运行：12cd &#123; 部署服务器的根目录 &#125; nohup forever start webhook.js &gt; deploy.log &amp; Ubuntu 中原本就有一个叫 node 的包。为了避免冲突，在 Ubuntu 上安装或使用 Node 得用 nodejs 这个名字。而 forever 默认是使用 node 作为执行脚本的程序名。所以为了处理 Ubuntu 存在的这种特殊情况，在启动 forever 时得另外添加一个参数：(其它则忽略) forever start webhook.js -c nodejs Github配置webhooks配置好 Webhook 后，Github 会发送一个 ping 来测试这个地址。如果成功了，那么这个 Webhook 前就会加上一个绿色的勾；如果你得到的是一个红色的叉，那就好好检查一下哪儿出问题了吧！ git-hook方式可采用一种更为简单的部署方式 这种方式和webhook可二选一 服务器上建立git裸库创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权一定要加 –bare，这样才是一个裸库。 12cd git init --bare blog.git 使用 git-hooks 同步网站根目录在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，新建post-receive文件。 vim ~/blog.git/hooks/post-receive 填入以下内容 12#!/bin/shgit --work-tree=/root/blog/public --git-dir=/root/blog.git checkout -f work-tree=/root/blog/public这个目录是网站的网页文件目录，–git-dir=/root/blog.git目录为裸库地址，裸库监听git提交会将文件提交到网页目录保存后，要赋予这个文件可执行权限chmod +x post-receive 配置博客根目录_config.yml完成自动化部署打开 _config.yml, 找到 deploy12345deploy: type: git repo: 用户名@SERVER名:/home/git/blog.git（裸库地址） //&lt;repository url&gt; branch: master //这里填写分支 [branch] message: 提交的信息 //自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) Nginx服务npm 安装nginx启动nginx 1service nginx start nginx -t 查看nginx配置文件若nginx服务启动，访问报403错误 则将首行 user nginx 改为user root 123456789vim /etc/nginx/nginx.confserver &#123; listen 80; # 监听端口 server_name 47.98.141.252:80 gangtieguo.cn wwww.gangtieguo.cn; # 你的域名 location / &#123; root /root/blog/public; index index.html; &#125;&#125; 重载 nginx，使配置生效 nginx -s reload 参考Hexo 静态博客搭建并实现自动部署到远程 vps将 Hexo 博客发布到自己的服务器上利用 Github 的 Webhook 功能和 Node.js 完成项目的自动部署Webhook 实践 —— 自动部署Hexo 快速搭建静态博客并实现远程 VPS 自动部署阿里云 VPS 搭建自己的的 Hexo 博客","categories":[{"name":"博客","slug":"博客","permalink":"http://gangtieguo.cn/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gangtieguo.cn/tags/Hexo/"}]},{"title":"MyBatis相关注解","slug":"MyBatis注解","date":"2018-05-17T12:09:55.000Z","updated":"2018-05-20T16:55:17.057Z","comments":true,"path":"2018/05/17/MyBatis注解/","link":"","permalink":"http://gangtieguo.cn/2018/05/17/MyBatis注解/","excerpt":"现接触MyBatic记录一些注解","text":"现接触MyBatic记录一些注解自动生成主键 可以使用 @Options 注解的 userGeneratedKeys 和 keyProperty 属性让数据库产生 auto_increment（自增长）列的值，然后将生成的值设置到输入参数对象的属性中。123@Insert(\"insert into students(name,sex,age) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;\") @Options(useGeneratedKeys = true, keyProperty =\"userId\") int insertUser(User user); 将自增的Id存入到userId属性中","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://gangtieguo.cn/tags/Java/"}]},{"title":"linux命令积累","slug":"linux命令积累","date":"2018-05-10T07:37:28.983Z","updated":"2018-05-11T05:22:56.238Z","comments":true,"path":"2018/05/10/linux命令积累/","link":"","permalink":"http://gangtieguo.cn/2018/05/10/linux命令积累/","excerpt":"简单linux命令","text":"简单linux命令nohup &amp;后台运行 文件查找find / -type f -size +10G在Linux下如何让文件让按大小单位为M,G等易读格式，S size大小排序。 ls -lhSdu -h * | sort -n当然您也可以结合管道文件夹内最大的几个文件 du -h * | sort -n|head动态显示机器各端口的链接情况while :; do netstat -apn | grep &quot;:80&quot; | wc -l; sleep 1; done sed更改第一行 sed -i &#39;1s/.*//&#39; sed -i ‘1s/.*/想更改的内容/‘删除第一行sed -i &#39;1d&#39; sed -i ‘1d’ 文件名插入第一行 sed -i &#39;1i\\&#39; sed -i ‘1i\\内容‘ 文件名 cpucat /proc/cpuinfo | grep processor | wc -llscpu","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://gangtieguo.cn/tags/开发/"},{"name":"linux","slug":"linux","permalink":"http://gangtieguo.cn/tags/linux/"}]},{"title":"博客备份.md","slug":"博客修改备份","date":"2018-05-08T10:34:55.000Z","updated":"2018-05-17T16:18:46.428Z","comments":true,"path":"2018/05/08/博客修改备份/","link":"","permalink":"http://gangtieguo.cn/2018/05/08/博客修改备份/","excerpt":"","text":"1234567891011121314151617&lt;% if (!is_post()) &#123; %&gt; &lt;% if (site.tags.length)&#123; %&gt; &lt;div class=&quot;widget tag&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;&lt;%= __(&apos;标签 :&apos;) %&gt;&lt;/h3&gt; &lt;%- list_categories(site.tags) %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% if (!is_post()) &#123; %&gt; &lt;% if (site.categories.length)&#123; %&gt; &lt;div class=&quot;widget tag&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;&lt;%= __(&apos;分类 :&apos;) %&gt;&lt;/h2&gt; &lt;h4&gt; &lt;%- list_categories(site.categories) %&gt;&lt;/h4&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; 123456&lt;% if (!index &amp;&amp; post.toc) &#123; %&gt; &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;&lt;%= __(&apos;&apos;) %&gt;&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;% &#125; %&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://gangtieguo.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gangtieguo.cn/tags/Hexo/"},{"name":"Other","slug":"Other","permalink":"http://gangtieguo.cn/tags/Other/"}]},{"title":"spring集成权限校验","slug":"spring集成权限校验","date":"2018-05-08T10:34:55.000Z","updated":"2018-05-17T12:21:22.941Z","comments":true,"path":"2018/05/08/spring集成权限校验/","link":"","permalink":"http://gangtieguo.cn/2018/05/08/spring集成权限校验/","excerpt":"shiro简介shiro是权限控制的一个框架是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。","text":"shiro简介shiro是权限控制的一个框架是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。 权限控制的方式权限有四种实现方式注解(基于代理),url拦截(基于过滤器),shiro标签库(基于标签),编写代码(及其不推荐)不论哪种方式:都需要引入spring用于整合shiro的过滤器 web.xml中:DelegatingFilterProxy=&gt;spring整合shiro配置spring提供的用于整合shiro框架的过滤器123456789101112131415 &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy &lt;/fileter&gt;``` filet-name需要和**spring配置文件**中的一个BEAN对象的id保持一致**非常重要** ### 配置 I. 注解方式,注解是利用生成的代理对象来完成权限校验: spring框架会为当前action对象(加注解的action)创建一个代理对象,如果有权限,就执行这个方法,不然就会报**异常**(将spring,Strust配置文件丰富:添加权限的注解,struts添加捕获异常,跳转页面) 1. 需要在spring配置文件中进行配置开启注解**DefaultAdvisorAutoProxyCreator**, 并配置成cjlib方式的注解 ```xml&lt;property name=\"proxyTargetClass\" value=\"true\"&gt;\\&lt;/property&gt; 注解实现权限当为jdk模式的时候方法注解实现权限过滤抛异常的原因:因为如果是jdk方式的话,实现的接口modelDriven只有一个getModel方法所以不能进行对除该方法外其他方法进行注解 定义切面类AuthorizationAttributeSourceAdvisor 1&lt;bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"&gt;&lt;/bean&gt; 在需要权限才能访问的方法上添加注解 1234567891011121314151617181920212223242526272829 @RequiresPermissions(\"relo_delete这是权限名称\") ``` II. url拦截(springxml) 基于过滤器或者拦截器实现 ```xml&lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;property name=\"loginUrl\" value=\"/login.jsp\"/&gt; &lt;property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; /css/** = anon /js/** = anon /images/** = anon /validatecode.jsp* = anon /login.jsp* = anon /userAction_login.action = anon /page_base_staff.action = perms[\"staff\"] /** = authc &lt;!--/** = authc--&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--开启自动代理,并且将代理代理模式设置为cjlib--&gt; &lt;bean id=\"defaultAdvisorAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"&gt; &lt;!--设置成cglib方式--&gt; &lt;property name=\"proxyTargetClass\" value=\"true\"&gt;&lt;/property&gt; &lt;/bean&gt; shiro的使用 在web.xml中引入用于创建shiro框架的过滤器web.xml中:DelegatingFilterProxy=&gt;spring整合shiro注意引入的位置:要在struts核心过滤器的前面,StrutsPrepareAndExcutFilter,不然,所有请求会通过struts过滤器获直接访问得到,shiro的过滤器将不会起到作用 在Spring中整合shiro2.1). shiro框架过滤器:ShiroFilterFactoryBean 需要声明那些过滤器,那些资源需要匹配那些过滤器,采用url拦截方式进行的路径对应的拦截器2.2). 配置安全管理器:DefaultWebSecurityManager 需要注入 自定义的Realm bean对象 1234567891011121314151617181920212223242526272829303132333435363738 &lt;!--配置一个shiro框架的过滤器工厂bean,用于创建shiro框架的过滤器--&gt; &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;property name=\"loginUrl\" value=\"/login.jsp\"/&gt; &lt;property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; /css/** = anon /js/** = anon /images/** = anon /validatecode.jsp* = anon /login.jsp* = anon /userAction_login.action = anon /page_base_staff.action = perms[\"staff\"] /** = authc &lt;!--/** 表示所有/下所有路径,包括下面的所有路径--&gt; &lt;!--/validatecode.jsp* 表示所有除了validatecode.jsp,还包括jsp后追加其他内容的.如validatecode.jsp?'+Math.random();防止验证码读取缓存 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--开启自动代理,并且将代理代理模式设置为cjlib 动态代理分为两类 基于jdk 创建的类必须要实现一个接口,这是面向接口的动态代理 基于cjlib 创建的类不能用final修饰--&gt; &lt;bean id=\"defaultAdvisorAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"&gt; &lt;!--设置成cglib方式--&gt; &lt;property name=\"proxyTargetClass\" value=\"true\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--定义aop通知+切入点--&gt; &lt;bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"&gt;&lt;/bean&gt; &lt;!--注入安全管理器--&gt; &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt; &lt;property name=\"realm\" ref=\"bosRealm\"&gt;&lt;/property&gt; &lt;property name=\"cacheManager\" ref=\"ehCacheManager\"&gt;&lt;/property&gt; &lt;/bean&gt; 在登陆认证的方法中加入subject controller中的login方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344public String login()&#123;Subject subject = SecurityUtils.getSubject(); //创建一个用户名密码令牌 AuthenticationToken token = new UsernamePasswordToken(getModel().getUsername(), MD5Utils.md5( getModel().getPassword())); try &#123; //认证 subject.login(token); &#125; catch (Exception e) &#123; this.addActionError(\"用户名或者密码错误\"); return LOGIN; &#125; /*当通过认证,跳入主页*/ User user = (User) subject.getPrincipal(); /*将用户信息存入session*/ ServletActionContext.getRequest().getSession().setAttribute(\"currentUser\", user); /*返回主页*/ return \"\";&#125;``` 4. 自定义Realm(用于权限的具体实施,即认证和授权)一般实现Realm接口的 **AuthorizingRealm** 实例 4.1实现认证 重写doGetAuthenticationInfo方法必须继承*AuthorizingRealm* 在需要交付给spring生成,并需要在安全注册管理器中注入属性Realm```javaprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;UsernamePasswordToken mytoken = (UsernamePasswordToken) token; String username = mytoken.getUsername(); DetachedCriteria dc = DetachedCriteria.forClass(User.class); dc.add(Restrictions.eq(\"username\",username)); List&lt;User&gt; list = userDao.findByCriteria(dc); if(list != null &amp;&amp; list.size() &gt;0)&#123; User user = list.get(0); String dbPassword = user.getPassword(); AuthenticationInfo info = new SimpleAuthenticationInfo(user,dbPassword,this.getName()); return info; &#125;else&#123; return null; &#125; &#125; 4.2实现授权 重写doGetAuthorizationInfo方法 12345678910111213141516171819202122232425262728293031323334353637383940protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;/*获的简单授权对象,用于授权的*/ SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); /*授权staff权限*/ //info.addStringPermission(\"staff\"); //步骤获得授权对象,获得当前用户,获得当前用户的权限(若为admin即授予所有权限),当前用户授权 //获得对象 User user = (User)principals.getPrimaryPrincipal(); List&lt;Function&gt; fList = null; //获得权限 if(user.getUsername().equals(\"admin\"))&#123; fList = functionDao.findAll(); &#125;else&#123; fList = functionDao.findFunctionByUserId(user.getId()); &#125; //授予权限 for(Function f : fList)&#123; info.addStringPermission(f.getCode());&#125;``` ## 关于Shiro中使用 **encache** 1.引入包 `在spring配置文件中配置以下` 2.配置文件ehcache.xml ```xml&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;defaultCache maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"true\" maxElementsOnDisk=\"10000000\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\" /&gt;&lt;/ehcache&gt; &lt;!--eternal是否永久有效--&gt; 3.引入缓存管理器EhCacheManager(shiro包中的),并设置配置文件;4.将缓存管理器注入安全管理器DefaultWebSecurityManager12345678910&lt;!--注册安全管理器--&gt;&lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt; &lt;property name=\"realm\" ref=\"bosRealm\"&gt;&lt;/property&gt; &lt;property name=\"cacheManager\" ref=\"ehCacheManager\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"bosRealm\" class=\"org.yao.bos.web.action.realm.BOSRealm\"&gt;&lt;/bean&gt; &lt;!--注入缓存管理器--&gt; &lt;bean id=\"ehCacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"&gt; &lt;property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://gangtieguo.cn/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gangtieguo.cn/tags/Java/"},{"name":"技术","slug":"技术","permalink":"http://gangtieguo.cn/tags/技术/"},{"name":"开发","slug":"开发","permalink":"http://gangtieguo.cn/tags/开发/"}]}]}